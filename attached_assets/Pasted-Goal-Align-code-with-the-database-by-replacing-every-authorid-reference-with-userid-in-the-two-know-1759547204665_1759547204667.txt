Goal

Align code with the database by replacing every authorid reference with userid in the two known files, then build, test, and push a branch for review. This restores author mapping for discussions, comments, likes, replies, and spouse tagging.

Step 1 — Create a safety branch
git checkout -b fix/userid-field-mismatch-20251003

Step 2 — Show all current occurrences (sanity check)
git --no-pager grep -n --color=always -E '\bauthorid\b' -- client/src/lib/supabase-data.ts server/storage-supabase.ts || true

Step 3 — Apply the precise replacement (word-boundary safe)
sed -i -E 's/\bauthorid\b/userid/g' client/src/lib/supabase-data.ts server/storage-supabase.ts

Step 4 — Re-list occurrences (should be empty)
git --no-pager grep -n --color=always -E '\bauthorid\b' -- client/src/lib/supabase-data.ts server/storage-supabase.ts || true

Step 5 — Quick diff for human verification
git --no-pager diff -- client/src/lib/supabase-data.ts server/storage-supabase.ts

Step 6 — Typecheck (if configured), then build
npm run -s typecheck --if-present && npm run -s build

Step 7 — Commit with a clear message
git add client/src/lib/supabase-data.ts server/storage-supabase.ts
git commit -m "fix: align user id field with DB (authorid→userid) across client & server; restore author mapping chain"

Step 8 — Push the branch
git push -u origin fix/userid-field-mismatch-20251003


(If the GitHub CLI is available and authenticated, you can open a PR automatically; otherwise, use the GitHub UI.)

gh pr create --fill --base main --head fix/userid-field-mismatch-20251003 || true

Step 9 — Runtime checks (post-merge or on a preview deployment)

Open /community

Threads show author name + avatar.

No author: null in the network response payload.

Open a thread detail view

Comments and replies show correct authors.

Interactions

Like/unlike works and stays correct on refresh.

Reply flow preserves author identity.

Tagged spouse (if present) renders without throwing.

Console/network sanity

No 4xx/5xx on user batch fetch.

usersMap constructed with real keys (user IDs).

Step 10 — Add a guardrail to prevent regressions (optional but recommended)
A. Enforce type correctness (compiler will catch future misuse)

Run this to fail CI if anyone re-introduces authorid:

git --no-pager grep -n -E '\bauthorid\b' -- ':!node_modules' && echo "Found forbidden field 'authorid'" && exit 1 || true


(Integrate that grep check into your CI after the build step.)

B. Lightweight runtime assertion (defensive programming)

In the mapping function that builds authorIds, add a tiny check to surface mis-shaped records early (no behavior change in production builds):

// after fetching threads
if (Array.isArray(threads) && threads.some(t => !('userid' in t))) {
  console.warn('Thread missing userid; sample:', threads.find(t => !('userid' in t)));
}

Why this works (succinct)

The DB emits userid.

The code was reading authorid, so authorIds was empty, user fetch skipped, usersMap empty, author became null.

The replacement realigns the field, re-enables the user batch fetch, and repopulates author objects throughout the UI.

If something looks off (alternative paths)

If any remaining code paths truly require an author alias for readability, introduce a non-breaking alias right after fetch (without changing the DB contract):

// one-time alias during normalization
thread.authorid = thread.userid; // for legacy code paths only; prefer direct userid usage


If types exist that still reference authorid, remove that field from the interface and require userid. This makes future regressions compile-time errors.