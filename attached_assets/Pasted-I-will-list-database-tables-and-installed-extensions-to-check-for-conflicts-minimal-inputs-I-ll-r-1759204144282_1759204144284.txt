I will list database tables and installed extensions to check for conflicts (minimal inputs). I'll run list_tables and list_extensions now.


Ran list_tables

Reasoned
Summary of findings
I inspected your public schema to find why the foreign key error occurs.

Your attached SQL creates users.id and many FKs referencing users(id) as INTEGER with SERIAL keys.
However, your existing database already has a users table whose id column is UUID (gen_random_uuid()) â€” and other tables (communitythreads, communitycomments, notifications, etc.) already reference users.id as UUID.
PostgreSQL cannot create a foreign key that references a column with a different data type (INTEGER vs UUID). That's why you get: foreign key constraint "community_threads_author_id_fkey" cannot be implemented
Cause
The error arises because your CREATE TABLE statements use SERIAL / INTEGER for primary keys and FK columns, but the existing schema uses UUID primary keys for users and related tables. When you attempt to create or alter tables that reference users(id) as INTEGER while users.id is UUID, Postgres refuses to create the FK.

Fix options (pick one)
Adapt your new DDL to use UUIDs (recommended, to match existing schema)

Use uuid columns and gen_random_uuid() defaults for primary keys and corresponding FK columns.
Example adjustments:
users: id UUID PRIMARY KEY DEFAULT gen_random_uuid()
community_threads.author_id UUID REFERENCES users(id)
community_comments.author_id UUID REFERENCES users(id)
and similarly for thread_likes.user_id, thread_follows.user_id, notifications.user_id, etc.
Convert the existing users.id to INTEGER (not recommended)

Changing an existing PK type when data exists is risky and complex (requires drop FKs, convert data, update all referencing columns). Only consider if you truly want integers and accept downtime/data migration.
If you intend to keep both styles (integers vs uuids), remove FK constraints and manage referential integrity in application code (not recommended).

Concrete DDL patch (recommended): convert your provided SQL to use UUIDs
Replace SERIAL/INTEGER uses with UUID where referencing users or other uuid PK tables. Example snippets (apply in your SQL editor):

Create users table:
SQL Query



CREATE TABLE IF NOT EXISTS users (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  username text UNIQUE NOT NULL,
  email text UNIQUE NOT NULL,
  display_name text NOT NULL,
  ...
);

community_threads:
SQL Query



CREATE TABLE IF NOT EXISTS community_threads (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  title text NOT NULL,
  content text,
  category text NOT NULL,
  author_id uuid REFERENCES users(id) NOT NULL,
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

community_comments (and other tables referencing users.id):
SQL Query



CREATE TABLE IF NOT EXISTS community_comments (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  content text NOT NULL,
  thread_id uuid REFERENCES community_threads(id) ON DELETE CASCADE NOT NULL,
  author_id uuid REFERENCES users(id) NOT NULL,
  parent_id uuid REFERENCES community_comments(id) ON DELETE CASCADE,
  created_at timestamptz DEFAULT now() NOT NULL
);

Repeat the same pattern for thread_likes.user_id, thread_follows.user_id, discussion_tags.tagged_user_id, episode_comments.author_id, video_likes.user_id, video_comments.author_id, notifications.user_id, chat_messages.user_id, etc.

Important: Use the same names (e.g., userid vs user_id) that your current schema uses; I saw existing columns named userid (lowercase, no underscore). If you adopt a different naming convention, either adapt to current naming or adjust your code.

Next steps
Do you want me to:
A) Produce a full corrected SQL script that replaces all SERIAL/INTEGER with UUIDs and matches your current naming (I can generate one)?
B) Produce migration steps to convert existing integer-based schema to UUIDs (if you prefer integers currently in DB)?
C) Inspect the current schema further for exact column names and generate an idempotent migration? (I can run more schema listing queries)
Pick one and I'll produce the needed SQL/migration.